#!/usr/bin/env python3
"""
AI-Powered Pentest Assistant
Provides intelligent guidance for penetration testing workflows
"""

import os
import json
import subprocess
import requests
import time
from datetime import datetime
from urllib.parse import urlparse

class PentestAI:
    def __init__(self):
        self.openai_key = os.getenv('OPENAI_API_KEY')
        self.anthropic_key = os.getenv('ANTHROPIC_API_KEY')
        self.results_dir = "/app/results"
        os.makedirs(self.results_dir, exist_ok=True)
        self.current_phase = "reconnaissance"
        self.findings = []
        self.target = None
        
    def run_command(self, command):
        """Execute command and return output"""
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=600)
            return result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            return "", "Command timed out"
        except Exception as e:
            return "", str(e)
    
    def ai_guidance(self, phase, context=""):
        """Get AI guidance for current pentest phase"""
        guidance = {
            "reconnaissance": """
            üéØ Reconnaissance Phase Guidance:
            
            1. **Information Gathering**
               - Whois lookup for domain ownership
               - DNS enumeration for subdomains
               - Network range identification
               - Social media analysis
            
            2. **Passive Reconnaissance**
               - Google dorking for exposed information
               - Shodan/Censys search for exposed services
               - Wayback machine analysis
               - GitHub reconnaissance
            
            3. **Active Reconnaissance**
               - Port scanning (nmap)
               - Service enumeration
               - Directory brute-forcing
               - Technology fingerprinting
            
            Recommended tools:
            - subfinder, amass for subdomains
            - nmap for port scanning
            - whatweb for technology detection
            - theHarvester for email gathering
            """,
            
            "scanning": """
            üîç Scanning Phase Guidance:
            
            1. **Port Scanning Strategy**
               - Start with TCP ports 1-1000
               - UDP scanning for common services
               - Version detection with -sV
               - Script scanning with -sC
            
            2. **Vulnerability Scanning**
               - Use Nessus/OpenVAS for comprehensive scanning
               - Nikto for web vulnerabilities
               - Nmap scripts for specific vulnerabilities
               - Check for default credentials
            
            3. **Web Application Scanning**
               - Directory enumeration with gobuster/dirb
               - Parameter discovery with Arjun
               - Header analysis
               - Cookie security analysis
            
            Recommended nmap commands:
            - nmap -sC -sV -oA detailed_scan <target>
            - nmap --script vuln <target>
            - nmap -p- --min-rate=1000 <target>
            """,
            
            "exploitation": """
            üí• Exploitation Phase Guidance:
            
            1. **Exploit Selection**
               - Match exploits to service versions
               - Consider Metasploit modules first
               - Verify exploit reliability
               - Test in lab environment first
            
            2. **Common Attack Vectors**
               - SQL injection for databases
               - Command injection in web apps
               - Buffer overflows in services
               - Misconfigurations and default credentials
            
            3. **Post-Exploitation**
               - Privilege escalation techniques
               - Lateral movement opportunities
               - Persistence mechanisms
               - Data exfiltration methods
            
            Important: Only exploit on systems you have permission to test!
            """,
            
            "post_exploitation": """
            üèÅ Post-Exploitation Phase Guidance:
            
            1. **Privilege Escalation**
               - Check SUID/GUID binaries
               - Exploit kernel vulnerabilities
               - Abuse sudo permissions
               - Cron job exploitation
            
            2. **Persistence**
               - Create backdoors
               - Add user accounts
               - Schedule tasks
               - Modify startup files
            
            3. **Lateral Movement**
               - Harvest credentials
               - Pass-the-hash attacks
               - SSH key theft
               - SMB relay attacks
            
            4. **Data Collection**
               - Sensitive file locations
               - Database extraction
               - Browser credentials
               - Configuration files
            """
        }
        
        return guidance.get(phase, f"Guidance not available for phase: {phase}")
    
    def automated_reconnaissance(self, target):
        """AI-guided automated reconnaissance"""
        print(f"üéØ Starting automated reconnaissance for {target}")
        self.target = target
        
        # Phase 1: Domain Information
        print("\nüìã Phase 1: Domain Information Gathering")
        
        # Whois
        whois_cmd = f"whois {target}"
        stdout, stderr = self.run_command(whois_cmd)
        
        # DNS enumeration
        dns_cmd = f"dig {target} ANY"
        stdout, stderr = self.run_command(dns_cmd)
        
        # Subdomain enumeration
        subfinder_cmd = f"subfinder -d {target} -o {self.results_dir}/subdomains.txt"
        stdout, stderr = self.run_command(subfinder_cmd)
        
        # Phase 2: Port Scanning
        print("\nüîç Phase 2: Port Scanning")
        
        # Quick scan
        quick_scan = f"nmap -F -oX {self.results_dir}/quick_scan.xml {target}"
        stdout, stderr = self.run_command(quick_scan)
        
        # Detailed scan of open ports
        detailed_scan = f"nmap -sC -sV -oX {self.results_dir}/detailed_scan.xml {target}"
        stdout, stderr = self.run_command(detailed_scan)
        
        # Phase 3: Web Assessment
        print("\nüåê Phase 3: Web Application Assessment")
        
        # WhatWeb
        whatweb_cmd = f"whatweb {target} -o {self.results_dir}/whatweb.json"
        stdout, stderr = self.run_command(whatweb_cmd)
        
        # Directory enumeration
        gobuster_cmd = f"gobuster dir -u http://{target} -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -o {self.results_dir}/gobuster.txt"
        stdout, stderr = self.run_command(gobuster_cmd)
        
        return {
            "subdomains": f"{self.results_dir}/subdomains.txt",
            "port_scan": f"{self.results_dir}/detailed_scan.xml",
            "web_tech": f"{self.results_dir}/whatweb.json",
            "directories": f"{self.results_dir}/gobuster.txt"
        }
    
    def vulnerability_assessment(self, target):
        """AI-guided vulnerability assessment"""
        print(f"üîç Starting vulnerability assessment for {target}")
        
        # Nikto web vulnerability scan
        nikto_cmd = f"nikto -h http://{target} -o {self.results_dir}/nikto.txt"
        stdout, stderr = self.run_command(nikto_cmd)
        
        # Nmap vulnerability scripts
        vuln_scan = f"nmap --script vuln {target} -oX {self.results_dir}/nmap_vuln.xml"
        stdout, stderr = self.run_command(vuln_scan)
        
        # SSL/TLS assessment
        ssl_scan = f"sslscan {target} > {self.results_dir}/sslscan.txt"
        stdout, stderr = self.run_command(ssl_scan)
        
        return {
            "web_vulns": f"{self.results_dir}/nikto.txt",
            "nmap_vulns": f"{self.results_dir}/nmap_vuln.xml",
            "ssl_issues": f"{self.results_dir}/sslscan.txt"
        }
    
    def generate_pentest_report(self, target, findings):
        """AI-enhanced pentest report generation"""
        report = f"""
# Penetration Testing Report

**Target:** {target}
**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Tester:** PentestAI Assistant

## Executive Summary

This report details the findings from a penetration test conducted against {target}. 
The assessment was performed using automated tools augmented with AI-powered analysis.

## Methodology

The penetration test followed these phases:
1. **Reconnaissance** - Information gathering and target enumeration
2. **Scanning** - Port scanning and service enumeration  
3. **Vulnerability Assessment** - Identification of security weaknesses
4. **Exploitation** - Attempted exploitation of identified vulnerabilities

## Findings

"""
        
        for i, finding in enumerate(findings, 1):
            report += f"""
### {i}. {finding.get('title', 'Finding')}

**Risk Level:** {finding.get('risk', 'Unknown')}
**Category:** {finding.get('category', 'General')}

**Description:**
{finding.get('description', 'No description available')}

**Evidence:**
{finding.get('evidence', 'No evidence provided')}

**Recommendation:**
{finding.get('recommendation', 'No recommendation available')}

---

"""
        
        report += f"""
## Risk Summary

- **Critical:** {len([f for f in findings if f.get('risk') == 'Critical'])} findings
- **High:** {len([f for f in findings if f.get('risk') == 'High'])} findings  
- **Medium:** {len([f for f in findings if f.get('risk') == 'Medium'])} findings
- **Low:** {len([f for f in findings if f.get('risk') == 'Low'])} findings

## Recommendations

1. **Immediate Actions (Critical/High)**
   - Address critical vulnerabilities immediately
   - Implement proper access controls
   - Update outdated software

2. **Short-term Actions (Medium)**
   - Implement security headers
   - Improve logging and monitoring
   - Conduct security training

3. **Long-term Actions (Low/General)**
   - Establish regular security testing
   - Implement security development lifecycle
   - Consider security framework adoption

## Conclusion

The penetration test identified {len(findings)} security issues that require attention. 
Priority should be given to addressing Critical and High risk findings to improve the overall security posture.

---

*Report generated by PentestAI - AI-powered penetration testing assistant*
"""
        
        # Save report
        report_file = f"{self.results_dir}/pentest_report_{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        with open(report_file, 'w') as f:
            f.write(report)
        
        return report_file
    
    def suggest_next_steps(self, current_phase, findings):
        """AI-powered next step recommendations"""
        suggestions = []
        
        if current_phase == "reconnaissance":
            suggestions.extend([
                "Review subdomain results for attack surface",
                "Analyze open ports for service vulnerabilities",
                "Research identified technologies for known exploits",
                "Check for exposed administrative interfaces"
            ])
        
        elif current_phase == "scanning":
            suggestions.extend([
                "Prioritize findings by exploitability",
                "Research exploits for high-risk services",
                "Test for default credentials",
                "Verify web application security controls"
            ])
        
        elif current_phase == "exploitation":
            suggestions.extend([
                "Document all successful exploits",
                "Maintain access for further testing",
                "Check for privilege escalation opportunities",
                "Assess lateral movement potential"
            ])
        
        return suggestions

def main():
    print("üéØ PentestAI - AI-Powered Pentest Assistant")
    print("=" * 50)
    
    pentest = PentestAI()
    
    while True:
        print(f"\nüéØ Current Phase: {pentest.current_phase}")
        print("\nüéØ PentestAI Options:")
        print("1. Get AI Guidance for Current Phase")
        print("2. Automated Reconnaissance")
        print("3. Vulnerability Assessment")
        print("4. Generate Pentest Report")
        print("5. Phase Progression")
        print("6. View Findings")
        print("7. Get Next Steps Recommendation")
        print("8. Exit")
        
        choice = input("\nSelect option (1-8): ")
        
        if choice == "1":
            guidance = pentest.ai_guidance(pentest.current_phase)
            print("\nü§ñ AI Guidance:")
            print(guidance)
            
        elif choice == "2":
            target = input("Enter target domain/IP: ")
            results = pentest.automated_reconnaissance(target)
            print(f"\n‚úÖ Reconnaissance complete. Results saved to {pentest.results_dir}")
            
        elif choice == "3":
            target = input("Enter target for vulnerability assessment: ")
            results = pentest.vulnerability_assessment(target)
            print(f"\n‚úÖ Vulnerability assessment complete. Results saved to {pentest.results_dir}")
            
        elif choice == "4":
            target = input("Enter target for report: ")
            if pentest.findings:
                report_file = pentest.generate_pentest_report(target, pentest.findings)
                print(f"üìÑ Pentest report generated: {report_file}")
            else:
                print("‚ùå No findings to report. Run reconnaissance first.")
                
        elif choice == "5":
            phases = ["reconnaissance", "scanning", "exploitation", "post_exploitation"]
            current_idx = phases.index(pentest.current_phase) if pentest.current_phase in phases else 0
            
            print(f"\nüìã Available Phases:")
            for i, phase in enumerate(phases):
                marker = "üëâ" if i == current_idx else "  "
                print(f"{marker} {i+1}. {phase}")
            
            phase_choice = input(f"\nSelect phase (1-{len(phases)}) or press Enter to stay: ")
            
            if phase_choice.isdigit() and 1 <= int(phase_choice) <= len(phases):
                pentest.current_phase = phases[int(phase_choice) - 1]
                print(f"‚úÖ Phase changed to: {pentest.current_phase}")
            else:
                print("‚ùå Invalid choice")
                
        elif choice == "6":
            if pentest.findings:
                print(f"\nüìã Current Findings ({len(pentest.findings)}):")
                for i, finding in enumerate(pentest.findings, 1):
                    print(f"{i}. {finding.get('title', 'Untitled')} - {finding.get('risk', 'Unknown')}")
            else:
                print("‚ùå No findings yet. Run reconnaissance first.")
                
        elif choice == "7":
            suggestions = pentest.suggest_next_steps(pentest.current_phase, pentest.findings)
            print(f"\nüéØ Next Steps for {pentest.current_phase}:")
            for i, suggestion in enumerate(suggestions, 1):
                print(f"{i}. {suggestion}")
                
        elif choice == "8":
            print("üëã Goodbye!")
            break
        
        else:
            print("‚ùå Invalid option. Please try again.")

if __name__ == "__main__":
    main()